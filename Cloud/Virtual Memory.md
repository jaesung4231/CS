# 가상 머신(Virtual Memory)

## 등장배경

**과거에는 소프트웨어의 발전 속도는 하드웨어의 발전 속도를 따라가지 못했다.**<br>
소프트웨어가 요구하는 서버 사양에 비해 소프트웨어 성능이 훨씬 좋다 보니 엄청난 비효율이 발생했다.<br>
**이러한 비효율 문제를 해결하기 위해 고안된 것이 바로 가상화 개념**이다.


## 가상 머신이란?

**가상 머신**은 물리적 하드웨어 시스템에 구축되어 자체 CPU, 메모리, 네트워크 인터페이스 및 스토리지를 갖추고 가상 컴퓨터 시스템으로 작동하는 가상 환경이다.

가상 서버를 만들기 위해서는 하이퍼바이저라는 소프트웨어에 전당한다. 요청을 받은 하이퍼바이저는 새로운 가상 서버를 생성하고, 물리 서버가 가진 컴퓨팅 리소스를 가상 서버에 할당해준다.<br>

이렇게 자체 컴퓨팅 자원과 OS를 갖춘 가상 컴퓨팅 환경을 가상 머신, Virtual Machine(VM)이라고 부른다.<br>

**이때 생성된 VM을 게스트 서버, VM들이 구됭되는 서버를 호스트 서버라고 부른다.**

## 하이퍼바이저란
**하이퍼바이저는 가상화 계층을 구현해주는 소프트웨어이다.**

하이퍼바이저는 물리 하드웨어와 가상 머신의 영역을 분리하고 자신이 그 사이에서 중간 관리자, 즉 인터페이스 역할을 한다.

### 유형 1 하이퍼바이저(Bare-Metal Hypervisor)

유형 1은 하드웨어 위에서 직접 구동되어 게스트 OS를 관리한다.하드웨어에 OS를 설치하는 것처럼 하이퍼바이저를 설치한다.<br>

유형 1 하이퍼바이저에는 호스트 OS가 따로 존재하지 않는다. 게스트 OS는 하드웨어 위에 2번째 수준으로 실행되기 때문에 오버헤드가 적다.
    
<img src='..\images\virtualization.png' width=600 align=center>


* **전가상화**<br>
    하드웨어를 완전히 가상화하는 방식<br>

    Guest OS는 자신이 가상머신의 OS인지 인지를 못한다.<br>

    Guest OS의 별다른 수정 없이 사용할 수 있다.<br>

    하이퍼바이저가 모든 명령을 중재하기 때문에 성능이 비교적 느리다.

* **반가상화**<br>
    전가상화와 달리 하드웨어를 완전히 가상화하지 않는 방식<br>

    Hyper Call이라는 인터페이스로 직접 하이퍼바이저에게 요청을 날리 수 있음, Guest OS가 자신이 Guest OS라는 사실을 인지한다.<br>

    Guest OS는 커버을 수정하여, Guest OS를 따로 만들어야 한다.<br>

    전가상화에 비해 성능이 빠르다.



### 유형 2 하이퍼바이저(Hosted Hypervisor)

유형 2는 Host OS를 갖는 하이퍼바이저이다. 하드웨어에 호스트 OS가 이미 설치되어 있고, 하이퍼바이저는 OS 위에서 소프트웨어로서 동작한다.<br>

기존 시스템 위에서 쉽게 사용할 수 있다는 것이 장점이지만, 게스트 OS가 하드웨어 위에 3번째 수준으로 실행되기 때문에 오버헤드가 크고, 호스트 OS의 문제가 게스트 OS에 영향을 줄 수 있다는 단점이 있다.

<img src='..\images\host_virtualization.png' width=400 align=center>

## 컨테이너란

소프트웨어 코드, 애플리케이션 코드가 작동하기 위해 필요한 컴포넌트와 함께 표준화된 방식으로 패키징해서 컨테이너 엔진만 있으면 돌아갈 수 있도록 하는 구조를 **컨테이너**라고 정의한다.

컨테이너 기술은 LXC(Linux Container)에서부터 출발한다. LXC는 호스트 OS에서 프로세스 간 벽을 만드는 기술로, 네임 스페이스와 cgroup을 조합한 형태이다.

* **네임 스페이스:** 리눅스 시스템 자원을 묶어 프로세스에 할당하는 방식으로, 하나의 프로세스 자원을 관리하는 기능
* **cgroup:** CPU, 메모리 등 프로세스 그룹의 시스템 자원 사용량을 관리하여 특정 어플이 자원을 과다하게 사용하는 것을 제한

    <img src='..\images\container.png' width=400 align=center>