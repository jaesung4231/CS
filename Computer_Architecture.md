# 컴퓨터 구조

### 컴퓨터의 구성 요소

- **프로세서**: 메모리로부터 명령어를 받아와 기계어로 변환(CU)하고 연산(ALU) 수행
- **메모리**: 명령어 및 데이터가 적재되는 공산
- **입출력 장치**: 데이터를 입력/출력하기 위한 컴퓨터의 외부 장치

### 메모리 영역

<img src='.\images\memory.png' width=300>

<br>

- **Code**: 소스 코드를 저장하는 영역
- **Data**: 전역변수, 정적변수, 배열 프로그램 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- **Heap**: 사용자에 의해 공간이 동적으로 할당되고 해제되는 영역, 함수의 호출과 관계되는 지역 변수와 매개 변수가 저장된다.
- **Stack**: 지역 변수, 매개 변수, 포인터 컴파일 타임에 크기 결정

```
힙과 스택은 사실 같은 공간을 공유한다. 힙이 메모리 위쪽 주소부터 할당되면 스택은 아래쪽부터 할당되는 방식, 각 영역이 침범하는 것을 힙 오버플로우, 스택 오버플로우라고 한다.
```

### 고정소수점, 부동소수점

- **고정소수점**: 고정소수점은 10진수를 2진수로 변경해서 그대로 사용하는 방식입니다. 부호부,정수부,소수부로 나누어서 표현

- **부동 소수점**: 2진수로 변경한 값을 그대로 사용하는 것이 아니라 정규화의 과정을 거친 다음 IEEE 부동소수점 표현방식인 부호부,지수부,가수부로 나누어서 표현

### 파이프라이닝

한 번에 하나의 명령어 처리가 아니라 하나의 명령어가 실행되는 도중에 다른 명령어도 실행하여, 각 단계에 있는 자원들을 놀리지 않고 역할을 부여함으로써, 동시에 여러 개의 명령어를 처리할 수 있게 하는 방식이다.

<img src='.\images\pipeline.png' width=350>

이때 처리 시간과 처리 단계가 균등하지 않아서 "해저드"라는 오류가 발생할 수 있다.

- **구조적 해저드**: 하나의 자원을 여려 개의 명령어에서 동시에 사용하려고 할 때 발생 <br>

- **데이터 해저드**: 준비되지 않은 명령어의 결과값이 다음 명령어의 입력으로 사용될 경우 발생

- **제어 해저드**ㅣ 제어 해저드는 분기가 결정된 시점에 수행되지 않을 명령어가 파이프라인에 존재할 때 발생

  **해결 방법**

- **구조적 해저드**: 명령어/ 데이터 메모리를 분리

- **데이터 해저드**: 접근 중인 데이터와 관련없는 명령어를 삽입

- **제어 해저드**: 명령이 분기하는지 미리 예측, 조건분기 최소화

### Cache

CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킨다.

이때 시간 지역성과 공간 지역성을 바탕으로 데이터를 가지고 온다.

#### 캐시 지역성

- **시간 지역성**: 한번 참조된 데이터는 다시 참조될 가능성이 높음

- **공간 지역성**: 참조된 데이터 주변의 데이터가 참조될 가능성이 높음

#### 캐시 미스

가져온 데이터가 캐시 메모리에 없는 경우

- **Cold miss**: 해당 데이터를 처음 호출해서 없는 경우를 의미

- **Conflict miss**: 여러 개의 명령어 주소가 같은 캐시메모리 주소에 저장되어 있는 경우에 발생

- **Capacity miss**: 캐시메모리의 공간이 부족해서 발생

#### 캐시 매핑

- **직접 매핑**: 메모리 주소와 캐시의 순서를 일치시킨다. 메모리가 1~100까지 있고 캐시가 1~10까지 있다면 1~10까지의 메모리는 캐시의 1에 위치하고 11~20까지의 메모리는 캐시의 2에 위치시키는 것이다. <br>
  구현은 간단하지만 규칙을 만족시켜서 캐시를 넣다 보면 캐시를 자꾸 교체되어야 하는 일이 발생한다.

- **연관 매핑**: 순서를 일치시키지 않는다. 필요한 메모리 값을 캐시의 어디든 편하게 저장될 수 있다. 찾는 과정은 복잡하고 느리지만, 정말 필요한 캐시들 위주로 저장할 수 있기 때문에 적중률은 높다. 캐시가 일반 메모리보다 속도가 훨씬 빠르므로 캐시의 검색량을 신경 쓰는 것 보단 적중률이 높은게 성능이 더 좋다.

- **직접 연관 매핑**: 연관매핑에 직접매핑을 합쳐 놓은 방식. 순서를 일치시키고 편하게 저장하되, 일정 그룹을 두어 그 그룹 내에서 편하게 저장시키는 것이다.<br>
  예를 들어 메모리가 1~100까지 있고 캐시가 1~10까지 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장시키는 것이다. 블록화가 되어 있기 때문에 검색은 좀 더 효율적으로 되고, 직접 매핑처럼 저장위치에 대한 큰 제약이 있는 건 아니기 때문에 적중률이 많이 떨어지지도 않는다.
