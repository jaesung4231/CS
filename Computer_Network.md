# 컴퓨터 네트워크(Computer Network)

### 프로토콜(Protocol)

- 둘 이상이 소통하기 위해 무엇을 어떻게 언제 같은 부분을 상호 동의한 약속
- 이미 오랫동안 했던 관습, 앞으로 할 약속

### 라우터

라우터 둘 이상의 패킷 전환 네트워크 또는 서브네트워크를 연결하는 장치

### OSI 7계층

- **OSI(Open System Interconnection): 국제 통신 표준 규약**<br>
  통신의 접속에서부터 완료까지의 과정을 7단계로 구분, 정의<br>
  <br>

* **Aplication Layer(응용 계층) (Hi 입력)** <br>
  사용자와 직접 연결되어 네크워크 접근을 돕는 계층<br>

  - 데이터 전송을 위한 인터페이스 제공<br>
  - 사용자로부터 입력 받은 정보를 하위계층에 전달함

* **Presentation Layer(표현 계층) (72 105 ASCII코드 변환)**<br>
  데이터를 응용계층에서 사용하는 표현으로 뱐환해주는 계층
  - 데이터의 인코딩과 디코딩이 이루어진다.
  - ex) 문자열을 ASCII코드로 변환
* **Session Layer(세션 계층) (HEAD | 72 105)**<br>

  컴퓨터 간 연결인 세션의 생성과 유지를 관리하는 계층

  - 다른 컴퓨터와의 연결을 담당하는 세션을 연다.
  - 오류 발생 시 복구 역할을 수행한다.<br>

  > **Session이란?**<br> 프로세스들 사이에서 통신을 하기 위해 메시지 교환을 통해 서로를 인식한 아후부터 통신을 마칠때 까지의 기간

* **Transport Layer(전송 계층) (H | 72 H | 105)**<br>
  End point간 데이터를 신뢰성 있게 전송하기 위한 계층<br>
  _ 패킷을 나누어 전송하고, 실패할 경우 다시 패킷을 보내는 등의 역할 수행한다.<br>
  _ TCP/UDP가 여기에 해당

* **Network Layer(네트워크 계층)( IP | H | 105 ) (Packet)**<br>
  데이터 전송 경로, 순서 등을 결정하는 계층
  데이터를 Packet단위로 분할하여 전송하고, 수신시 합치는 역할을 한다.<br>

  - IP주소를 사용하여 데이터를 전송한다.<br>
  - 다양한 경로들 중에서 가장 빠르고 효울적인 경로를 파악하고 결정해준 역할

  > **Transport Layer과 Network Layer 차이점**<br>
  > 트랜스포트 계층 프로토콜은 서로 다른 호스트에서 동작하는 프로세스 사이의 통신을 제공하지만, 네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신을 비교한다.

* **Date Link Layer (데이터 링크 계층) (MAC | IP | H | 105) (Frame)**<br>
  물리적인 기기들 사이에서 데이터를 전송하는 계층 - 맥 주소를 통해 통신<br>

  > **맥 주소(Mac Address)란?**<br>
  > 하나의 고유한 주소를 부여해서 통신을 할 수 있도록 만든 일종의 하드웨어 주소다.

* **Physical Layer (물리 계층) (1101001)**<br>
  데이터를 물리적인 신호로 변환하는 계층<br>

  - 비트 단위의 전기 신호를 전달한다.<br>
  - 데이터를 전송하는 역할만 진행한다.<br>
    <br>

### **GET이란?**<br>

클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 매소드이다.<br>

GET 요청은 캐시가 가능하다. 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다.

### **POST이란?**<br>

POST는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용되는 메서드다.

### **HTTP의 GET과 POST비교**<br>

- **사용 목적:** GET은 서버의 리소스에서 데이터 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 떄 사용한다.

- **요청에 body 유뮤:** GET은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다, POST는 body에 데이터를 담아 보내기 때문에 HTTP 메세지에 body가 존재한다.
- **멱등성:** GET 요청은 멱등성이며, POST은 멱등이 아니다.
  > **멱등성**<br> 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다.

### **TCP/IP 모델**<br>

- 연결형 서비스를 지원하는 프로토콜

- Application Layer, Tranport Layer, Network Access Layer 로 구성되어 있음

- **동작 과정**<br> 소켓 생성 => 3-way Handshake => 데이터 송신, 수신 => 4-way Handshake

  > TCP 헤더 중, 6비트로 구성된 TCP플래그(코드 비트)로 확인함

* **TCP 3-way Handshake**<br>
  TCP 3-way handshake는 세션 연결을 확립하기 위한 과정<br>
    <p align="center"><img src='.\images\3-way-handshake.png' align="center" width=500><p>

* **TCP 4-way Handshake**<br>
  TCP 4-way handshake는 세션 연결을 종료할 시에 거치는 과정<br>
  <p align="center"><img src='.\images\4-way-handshake.png' align="center" width=500><p>

* **TCP에서 Reliable network를 보장한다는 것은 4가지 문제점**<br>

  - 손실: packet이 손실될 수 있는 문제
  - 순서 바뀜: packet의 순서가 바뀌는 문제
  - Congestion: 네트워크가 혼잡한 문제
  - Overload: receiver가 overload 되는 문제

### **TCP 흐름제어**<br>

송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법

수신측에는 패킷을 받을 수 있는 버퍼의 크기가 정해져있는데, 만약 송신측의 전송 속도가 너무 빨라 한 번에 많은 패킷을 수신 받아버린다면, 버퍼가 가득파 손실되는 패킷들이 발생할 것이다. 즉, 송신측 처리 속도가 더 빠를 경우, 제어할 수단이 필요하다.

- **TCP 흐름제어 방법**

  - **Stop-and -Wait**<br>
    매번 전송한 패킷에 대한 확인 응답을 받아야만 그 다음 패킷을 전송하는 기법
  - **Go-back-N**<br>
    한번에 여러 개 보내서 못 받은 게 있으면 못 받은 것부터 다시 전송하는 기법

### **TCP 혼잡제어**<br>

데이터의 양이 수신 측에서 처리할 수 있는 양을 초과하게 되면, 송신 측에서는 수신 측에서 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하게 되므로 네트워크가 혼잡해진다 이러한 혼잡 상태를 제어하는 것을 혼잡 제어라고 한다.

- **혼잡제어 기법**

  - **AIMD (Addictive Increase / Multicative Decrease)**<br>
    AIMD 방식은 처음에 패킷을 하나씩 보내고 문제없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송한다. 만약, 전송에 실패하면 윈도우 크기를 반으로 줄인다. 윈도우 크기를 너무 조금씩 늘리기 떄문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래걸린가는 단점이 있다.

  - **Slow start**<br>
    AIMD 방식은 윈도우 크기를 선형적으로 증가시키기 때문에, 제대로된 속도가 나오기까지 시간이 오래 걸린다. 반면, Slow Start는 윈도우의 크기를 1, 2, 4, 8과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식이다.

  - **Fast Retransmit (빠른 재전송)**<br>
    순서에 맞지 않는 패킷이 온 경우, 잘 도착한 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 이런 중복 ACK를 3개 받으면 재전송이 이루어진다. 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 있기 때문에 빠른 재전송을 유지할 수 있다.

  - **Fast Recovery (빠른 회복)**<br>
  빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.

    <p align="center"><img src='.\images\congestion.png' align="center" width=500><p>

* **혼잡제어 정책**<br>

  - **Tahoe**<br>
    Slow Start, AIMD, Fast Retransmit의 결합이다.

    처음 전송 시 적은 데이터를 전송한 후, RTT(Round Trip Time) 확인 후 괜찮다는 판단이 들면 congestion window size(cwnd)를 두 배로 늘린다. 여기서 cwnd가 임계점(Threshold)에 도달하면 전송을 중단한 후 윈도우 크기를 1로 줄인다. Tahoe에서는 이후 AIMD로 넘어간다.

    **단점**<br> 손실 감지가 발생한 수 cwnd 크기가 초기의 윈도우 사이즈로 지정된 후 1씩 커지다보니 속도가 느리다. 이를 보완하기 위해 TCP Reno가 나타났다.

  - **Reno**<br>
    Tohe와 Fast Recovery의 결합. TCP Tahoe의 Slow Start, AIMD, Fast Retransmit과 동일하다. <br>
    - **Fast Recovery**<br>
    Reno에서는 duplicate ACK와 timeout을 구분한다. 전자의 경우 cwnd를 초기 윈도우 사이즈가 아닌 현재 cwnd의 절반으로 줄인다. 중복 상태라는 것은 패킷이 수신기로 전달된다는 의미이다. 따라서 cwnd는 네크워크가 정체 상태에서 벗어나도록 하기 위해 절반으로 감소시킨다. 이때, 임계점도 cwnd 값으로 설정한다. 반대로 timeout의 경우, cwnd를 초기의 윈도우 사이즈로 지정시키고 임계점도 변하지 않는다. duplicate ACK와 비교하여 네트워크가 혼잡하다는 것을 의미하기에 복구가 필요하다.
    <p align="center"><img src='.\images\tahoe.png' align="center" width=500><p>

### **UDP(User Datagram Protocol)**<br>

- 비열결형 서비스
- 신뢰성이 없으며, 순서화되지 않은 데이터그램 서비스 제공
  > 연결 과정이 없기 때문에 TCP보다 빠른 전송이 가능하지만, 데이터가 유실될 수 있고, 데이터 패킷을 순차적으로 보내더라도 먼저 보낸 패킷이 느린 선로를 통해 전송될 경우 나중에 보낸 패킷보다 늦게 수신될 수 있다.

### **TCP/UDP의 차이**

- **TCP:** 신뢰도 높지만, 전송 속도 느림, HTTP 2.0이하의 버전 대부분에서 사용된다.<br>
- **UDP:** 신뢰성 낮음, 전송 속도 빠름, DNS, 동영상, 음성 데이터<br>

### **HTTP**

브라우저와 서버가 통신할 수 있도록 만들어주는 여러 프로토콜 가운데 한 종류로 웹 브라우저와 웹 서버 사이에 HTML(웹 문서를 만들기 위한 언어) 문서를 주고받는데 쓰이는 통신 프로토콜

- **HTTP(Hyper Text Transfer Protocol)**<br> 하이퍼 텍스트를 전송하기 위해 만들어진 약속<br>

* **HTTP 프로토콜의 특징**<br>

  - HTTP에서는 클라이언트가 서버에 요청 메세지를 보내고 서버는 클라이언트의 요청에 대한 응답을 반환한다.
    연결 상태를 유지하지 않는 비연결성 프로토콜이며, **요청과 응답 방식**으로 동작한다.<br>

  - 연결 상태를 유지하지 않는다는 말은 서버는 응답 메시지를 반환한 후에 클라이언트의 상태를 저장하지 않는다는 것이다. 때문에 HTTP프로토콜은 상태가 없는 **무상태성(stateless)**라고도 불린다.

* **HTTP Request의 구조**

  - **Request Line**<br>

    - HTTP 메서드(GET,POST 등)를 사용해 서버가 수행해야 할 동작을 나타낸다.
    - 요청 타켓(URL, 프로토코르 포트, 도메인)을 나타내며, 이들은 요청 컨텍스트에 의해 특정 지어진다.
    - HTTP 버전이 들어간다. 응답 메시지에 사용할 HTTP 버전을 알려주는 역할

  - **Header**<br>

    - 요청에 들어가는 HTTP헤더는 HTTP 헤더 기본 구조를 따른다.
    - 대소문자 구분 없는 문자열 다음 클론(' : ')이 붙으며, 그 뒤에 오는 값은 헤더에 따라 달라진다.
    - 헤더를 세분화하면 General Header, Request Header, Entity Header로 나눌 수 있다.

  - **Body**<br>
    - request의 마지막 부분에 들어간다. 모든 요청에 들어가지는 않고 Get, HEAD, DELETE, OPTIONS처럼 리소스를 가지고 오는 요청은 대부분 본문을 필요로 하지 않는다.

* **HTTP Response의 구조**

  - **Status Line**<br>

    - 프로토콜 버전
    - 상태 코드, 요청의 성공 여부를 나타낸다.
    - 상태 텍스트, 짧고 간결하게 상태 코드에 대한 설명을 글로 나타낸다.

  - **Header**<br>

    - 응답에 들어가는 HTTP 헤더는 요청과 마찬가지로 HTTP 헤더의 기본 구조를 따른다.
    - 대소문자 구분 없는 문자얄 다음 클론(' : ')이 붙으며, 그 위에 오는 값은 헤더에 따라 달라질 수 있다.
    - 헤더를 세분화하면 General Header, Request Header, Entity Header으로 나눌 수 있다.

  - **Body**<br>
    - response의 마지막 부분에 들어간다. 모든 응답에 들어가지는 않고 201, 204 같은 상태 코드를 가진 응답에는 보통 본문이 없다.
    - reponse body는 이미 길이가 알려진 단일 파일로 구성된 헤더 두 개를 가진 단일-리소스 본문, 길이를 모르는 단일 파일로 구성된 단일-리소스 본문, 서로 다른 정보를 담고 있는 멀티파트로 이루어진 다중-리소스 본문 이렇게 크게 3가지로 나눌 수 있다.

### **HTTP와 HTTPS**

- **HTTP의 단점:**<br>

  1. 암호화하지 않았기 때문에 도청 당할 수 있다.
  2. 통신 상대를 확인하지 않기 때문에 위장이 가능하다. (상대방이 허가된 상대인지 확인할 수 없다.)

- **HTTPS (HTTP + SSL)**<br>
  HTTP 통신하는 소켓 부분을 SSL or TLS라는 프로토콜로 대체하는 것 뿐이다.<br>

  HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신하게 된다.<br>
