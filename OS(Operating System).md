# 운영체제

운영 체제는 컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고 작동하도록 하는 소프트웨어 프로그램

사용자가 불편함 없이 프로세스를 사용하며, 컴퓨터 내부적으로는 효율적으로 메모리를 관리해야 한다.

### 사용자 모드

사용자 모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어에 접근할 수 없다.

### 커널 모드

운영 체제가 CPU를 사용하는 모드다.<br>
시스템 콜을 통해 커널 모드로 전환 되며, 운영체제는 하드웨어를 제어하는 명령어를 실행한다.

### 시스템 콜(System Call)

응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.

### 인터럽트(Interupt), 예외(Exception)

- **인터럽트(Interupt)**<br>
  CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요한 경우에 마이크로프로세서에게 알려 처리할 수 있도옥 하는 것.

- **예외(Exception)**<br>
  프로세서 내부에서 발생하는 예상치 못한 사건

- **내부 인터럽트(Internal interrupt)** - (Exception)

  > - 산술 오버플로우/언터플로우 (Overflow/Underflow)
  > - 0으로 나누기(Division by zero)
  > - 정의 안된 명령어 수행

- **외부 인터럽트(External Interrupt)**
  > - I/O 인터럽트: 입출력 요구가 있을 떄, 하드웨어가 발생
  > - 기계 착오 인터럽트: CPU등의 기능적인 오류

* **인터럽트 과정**<br>
  <img src='.\images\interrupt.png' width=500>

### 프로세스

프로그램을 메모리 상에서 실행중인 작업의 단위<br>
각각 독립된 메모리 영역을 할당받는다.

<img src='.\images\process_state.png' width=500 align=center>

- 프로세스 상태
  > - **new**: 프로세스가 생성 중이다
  > - **ready**: 프로세스가 프로세서에 할당되기를 기다리고 있는 상태, ready 큐에서 실행 준비중
  > - **waiting**: 프로세스에 입출력 처리가 필요하며 현재 실행 중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태
  > - **terminated**: 프로세스의 실행이 끝나고 프로세스 할당이 해지된 상태

### 스레드(Thread)

스레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며 작업을 수행한다. 프로세스 내에서 각각 stack만 할당받고, code, data, heap영역을 공유한다.

### 프로세스 context switching vs 스레드 context switching

쓰레드 간의 통신이 필요한 경우, 별도의 자원을 이용하는 것이 아니라 데이터(Data) 영역 또는 힙(Heap) 영역을 이용하여 데이터를 주고받을 수 있다.

process context switching이 발생할 경우 processor는 thread의 context뿐만 아니라 process의 context까지 모두 변경해야 한다.

> **context switching이란?**<br>
> context switchomg이란 한 프로세스에서 다른 프로세스로 제어권을 넘겨주는 것

### 멀티스레드 vs 멀티프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있다.<br>

멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.

### 임계 구역(Critical Section)

여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분

### 경쟁 상태(Race Condition)

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태

**해결법:** crictical section에 mutual exclusion을 제공. 공유 자원은 하나의 스레드나 프로세스만 접근할 수 있게 한다.

### Lock의 요구사항

- **Correctness(정확성)**

1.  Mutual exclusion: 같은 시간에 하나의 스레드만이 Critical Section에 접근할 수 있다.
2.  Progess: 여러 스레드가 동시에 Critical Section에 접근하려고 할때
3.  Bounded waiting: starvation-free, 결국 모든 스레드가 Critical Section에 접근할 수 있어야 한다.

- **Fairness**<br>
  모든 스레드는 공평하게 lock의 기회를 받아야 한다.

- **Performance**<br>
  기본적인 성능이 보장되어야 한다.

### Lock의 종류

- **Mutex Lock(Binary semaphore)**<br>
  하나의 자원에는 하나의 프로세스나 스레드만 할당 받을 수 있다. 동시에 접근하지 못하게 Lock를 걸어둠

- **Spin Lock(Mutex Lock의 Busy-wait 제공)**<br>
  다른 스레드가 Crictical section에 lock을 점유한 상황에서 lock을 반환하기까지 계속 loop를 돌며 확인하고 기다리는 것.<br>

  > Mutex의 경우에는 다른 스레드가 lock을 점유한 경우에 sleep에 빠짐. 다른 스레드의 작업이 끝나도 lock을 반환하면 awake되면서 lock획득을 재시도

- **Semaphore(counting semaphore)**<br>
  가용한 개수를 가진 자원에 대한 접근을 허용

### 데드락(DeadLock)

교착 상태는 2 개 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상이다.

교착 상태의 발생 조건은 아래 4가지를 모두 만족하는 것이다. 하나라고 만족하지 않으면 절대로 데드락이 발생하지 않는다.

- **상호 배제:** 한 리소스는 한 번에 하나의 프로세스만 사용할 수 있다.
- **점유와 대기:** 어떤 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
- **선점 불가:** 다른 프로세스에 할당된 자원은 사용
- **순환:** Hold and Wait 관계의 프로세스들이 서로 기다린다.

### 교착 상태 대처 방안

- **예방**: 할당 구조 측면에서, 교착 상태가 발생할 수 있는 요구조건을 만족시키지 않게 한다.
- **회피**: 리소스 할당 측면에서, 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않는다.
- **탐지 및 회복**: 교착 상태가 발생할 수 있도록 두고 교착 생태가 발생할 경우 찾아내어 고친다.

#### 교착 상태 예방

교착 상태를 방지하기 위해서는 4가지 조건 중에 하나 이상을 불만족시키면 된다.

- **상호 배제 부정:**<br> 여러 개의 프로세스가 동시에 공유 자원을 사용할 수 있다.<br>
  **_문제점:_** 공유 자원에 대한 관리가 이루어질 수 없고 제대로 프로그램이 작동될 수가 없다.

- **점유 및 대기 부정:** <br>
  프로세스가 실행되기 전에 필요한 모든 자원을 다 할당할 때 까지 실행되지 않도록 하거나, 반대로 자원을 요청하기 위해서는 어떠한 자원도 가지지 않았을 때 요청이 가능하도록 한다.<br>
  **_문제점:_** 프로세스가 실행되기 위해서 필요한 자원에 대한 정보를 미리 파악해야 하기 때문에 시간 낭비 발생, 자원의 효율성이 떨어지고 기아상태가 발생할 수 있다.
  <br>

- **비선점 부정:**<br> 다른 프로세스에 할당된 자원을 가져와서 사용 가능하게 한다.<br>
  **_문제점:_** 공유 자원에 대한 동기화에 대한 의미가 깨져버리는 방식으로 실질적으로 불가능

- **순환 대기 부정:** <br>자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.<br>
  **_문제점:_** 그나마 현실적인 방법. 중첩되어 있는 공유자원 사이에 요청 순서를 임의적으로 정해줌으로써 여러 개의 프로세스가 순환형 대기에 머물러 있게 되는 상황을 방지하는 기법이다.

#### 교착 상태 회피

교착 상태 회피는 교착 상태를 피해가는 기법

- **은행원 알고리즘(Banker Algorithm):**<br>

  교착상태에 빠질 가능성이 있는지, 없는지를 판단하기 위해 상태를 ‘안전 상태’와 ‘불안전 상태’로 나눈다. 그리고 운영체제는 안전상태를 유지할 수 있는 요구만 수락해주고, 나머지 요구들은 안전상태를 만족할 때까지 계속 거절한다.

1. 프로세스 시작 시 자신이 필요한 각 자원의 최대 개수를 미리 선언

2. 프로세스에서 자원 요청이 있을 때, 요청을 승인하면 시스템이 안전한 상태로 유지되는 경우에만 할당

3. 불안정 상태가 예상되면 다른 프로세스가 끝날때 까지 대기
   <br>
   <br>

- **자원 할당 그래프 알고리즘(Resource-Allocation Graph Algorithm)**<br>

1. 자원 할당 그래프 예약 간선을 추가한다. (예약 간선): 향후 요청할 수 있는 자원을 가르키는 점선으로 표시된 간선

2. 프로세스 시작 전에 모든 예약 간선들을 자원할당 그래프에 표시<br>

3. 프로세스는 예약 간선으로 설정한 자원에 대해서만 요청할 수 있고, 주기가 형성되지 않을 때에만 자원을 할당

#### 교착 상태 탐지

교착 상태 탐지는 탐지 알고리즘을 사용하여 교착상태가 발생했는지 탐지한다.

- **대기 그래프(wait-for-graph)**<br>
  자원 할당 그래프를 변형한 대기 그래프를 사용하여 탐지한다.<br>
  대기 그래프에 cycle이 있다면 교착 상태를 의미한다.

- **은행원 알고리즘(Banker's Algorithm)**<br>

1. 각 프로세스의 자원 요청 개수를 사용

2. 현재 상태가 안전 상태인지 확인

3. 불안정 상태라면 교착 상태라고 판단

> **탐지 알고리즘 호출 주기**<br>
> 탐지 알고리즘은 오버헤드가 있기 때문에, 얼마나 자주 교착상태가 발생하는지, 얼마나 많은 프로세스가 교착상태에 연루되어 있는지에 따라 호출 빈도를 조절해야 한다.<br>
> Ex)<br>
> 주기적으로 일정 시간마다 호출<br>
> 자원을 요청했는데 즉시 할당되지 못하는 시점에 호출

#### 교착 상태 복구

교착 상태가 발생했다면 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제함으로써 복구를 한다.

1. **프로세스 종료**<br>

- 교착 상태의 프로세스를 모두 중지
- 교착 상태가 제거될 떄까지 한 프로세스씩 중지

2. **자원 선점**<br>

- 희생자 선택: 최소의 피해를 줄 수 있는 프로세스 선택
- 롤백: 선점된 프로세스를 문제없던 이전 상태로 롤백

3. **기아 상태**<br>

- 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지 ex) 우선순위 사용

### 컴퓨터의 주소

- **물리적 주소(Physical Address)**<br>
  메모리 상의 물리적인 주소

- **논리적 주소(Logical Address or Virtual Address)**<br>
  논리 주소는 CPU에 의해 프로그램이 실행되고 있을 때 만들어진다.<br>
  **MMU(Memory-Management Unit)** 라는 하드웨어 장치는 논리 주소와 대응되는 물리 주소를 연결한다.

### 가상 메모리(Virtual Memory)

가상메모리는 프로세스들에게 각각의 비어 있는 메모리 영역을 부여한다. 메모리 영역은 처음부터 비어 있는 상태다. 프로세스의 가상 메모리 접근은 결국 물리 메모리로의 접근으로 이어진다.

### Swapping

메모리 관리를 위해 사용되는 기법.

1. 일부 프로세스를 메모리에서 디스크로 보내고(swap-out), 시간이 흘러 메모리에 여유가 생기면 다시 적재(swap-in)한다.
2. 중기 스케줄러는 스와퍼(Swapper)을 통해 프로세스들이 CPU경쟁이 심해지는 것을 방지하는 역할을 한다.

### 메모리 관리(Partition/Page/Segment)

- **연속적 할당(Contiguous allocation)**<br>
  프로세스를 분리되지 않은 하나의 덩어리로 실행

  - **Fixed Partition**<br>
    메모리를 미리 분할해 놓고, 하나의 파티션에 한 프로그램만 할당하는 방식

    - **균등 고정분할 방식(equal-size partitioning)**: 모든 파티션을 같은 크기로 분할하는 방식

    - **불균등 고정분할 방식(unequal-size partitioning)**: 메모리 상황을 고려해서, 필요한만큼 파티션을 잡고 분할해준다. 파티션을 필요한 크기와 정확히 동일하게 잡기 때문에 내부 단편화는 발생하지 않는다.

  - **Dynamic partitioning**<br>
    요청이 왔을 때의 메모리 상황을 고려해서, 필요한만큼 파티션을 잡고 분할해준다.

  <p align="center"><img src='.\images\contiguous.png' align="center" width=500><p>

- **Buddy System**<br>
  기본크기인 블럭(block) 단위로 미리 분할해두고, 프로세스의 요청이 있으면 요청한 크기에 맞게 동적으로 블럭을 분할해서 할당하는 방식이다.

1. 메인 메모리는 항상 2^N로 할당한다.
2. 사용할 수 있는 가장 큰 메모리로부터 시작해서 Binary로 절반씩 쪼개나면서 아래 조건을 만족시키는 공간을 찾는다.
3. 만약 프로세스 메모리 크기가 K라고 하면, 2^(U-1) < K < 2^U 만큼의 공간에 프로세스를 할당한다.<br> ex) 프로세스 크기가 1000B이면, 512B < 1000B < 1024B이기 때문에 1024B 사이즈의 메모리에 할당하는 것이다.
4. 프로세스가 종료되고, 만약 같은 Parent를 갖는 Buddy 공간이 비어있다면 Merge한다.
<p align="center"><img src='.\images\buddy-system.png' align="center" width=500><p>

- **불연속적 할당(Non-contiguous allocation)**<br>

  - **페이징**<br>
    한 프로그램을 여러 단위로 나누어 분산 적재하는 방법이다.<br>
    page: 프로세스의 조각<br>
    frame: 메인 메모리의 조간

    내부 단편화(Internal fragmentation)이 발생할 수 있다.

    **장점:** 내부 단편화(Internal fragmentation)이 발생하지 않는다.<br>

    **단점:** 외부 단편화(External fragmentation)이 발생한다.

<p align="center"><img src='.\images\paging.png' align="center" width=500><p>

- **Segmentation**<br>
  page는 고정 길이였다면 segment는 논리단위로 프로그램을 나눈다. 나누는 기준은 OS별로 상이하다.

  segmentation table이 필요하며, 각 segment는 시작 주소와 길이를 저장한다.

  **장점:** 내부 단편화(Internal fragmentation)이 발생하지 않는다.<br>

  **단점:** 외부 단편화(External fragmentation)이 발생한다.
