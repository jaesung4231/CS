# 운영체제

운영 체제는 컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고 작동하도록 하는 소프트웨어 프로그램

사용자가 불편함 없이 프로세스를 사용하며, 컴퓨터 내부적으로는 효율적으로 메모리를 관리해야 한다.

### 사용자 모드

사용자 모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어에 접근할 수 없다.

### 커널 모드

운영 체제가 CPU를 사용하는 모드다.<br>
시스템 콜을 통해 커널 모드로 전환 되며, 운영체제는 하드웨어를 제어하는 명령어를 실행한다.

### 시스템 콜(System Call)

응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.

### 인터럽트(Interupt), 예외(Exception)

- **인터럽트(Interupt)**<br>
  CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 예외상황이 발생하여 처리가 필요한 경우에 마이크로프로세서에게 알려 처리할 수 있도옥 하는 것.

- **예외(Exception)**<br>
  프로세서 내부에서 발생하는 예상치 못한 사건

- **내부 인터럽트(Internal interrupt)** - (Exception)

  > - 산술 오버플로우/언터플로우 (Overflow/Underflow)
  > - 0으로 나누기(Division by zero)
  > - 정의 안된 명령어 수행

- **외부 인터럽트(External Interrupt)**
  > - I/O 인터럽트: 입출력 요구가 있을 떄, 하드웨어가 발생
  > - 기계 착오 인터럽트: CPU등의 기능적인 오류

* **인터럽트 과정**<br>
  <img src='.\images\interrupt.png' width=500>

### 프로세스

프로그램을 메모리 상에서 실행중인 작업의 단위<br>
각각 독립된 메모리 영역을 할당받는다.

<img src='.\images\process_state.png' width=400 align=center>

- 프로세스 상태
  > - **new**: 프로세스가 생성 중이다
  > - **ready**: 프로세스가 프로세서에 할당되기를 기다리고 있는 상태, ready 큐에서 실행 준비중
  > - **waiting**: 프로세스에 입출력 처리가 필요하며 현재 실행 중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태
  > - **terminated**: 프로세스의 실행이 끝나고 프로세스 할당이 해지된 상태

### 스레드(Thread)

스레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며 작업을 수행한다. 프로세스 내에서 각각 stack만 할당받고, code, data, heap영역을 공유한다.

### 프로세스 context switching vs 스레드 context switching

쓰레드 간의 통신이 필요한 경우, 별도의 자원을 이용하는 것이 아니라 데이터(Data) 영역 또는 힙(Heap) 영역을 이용하여 데이터를 주고받을 수 있다.

process context switching이 발생할 경우 processor는 thread의 context뿐만 아니라 process의 context까지 모두 변경해야 한다.

> **context switching이란?**<br>
> context switchomg이란 한 프로세스에서 다른 프로세스로 제어권을 넘겨주는 것

### 멀티스레드 vs 멀티프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료될 위험을 갖고 있다.<br>

멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.

### 데드락(DeadLock)

교착 상태는 2 개 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상이다.

교착 상태의 발생 조건은 아래 4가지를 모두 만족하는 것이다. 하나라고 만족하지 않으면 절대로 데드락이 발생하지 않는다.

- **상호 배제:** 한 리소스는 한 번에 하나의 프로세스만 사용할 수 있다.
- **점유와 대기:** 어떤 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
- **선점 불가:** 다른 프로세스에 할당된 자원은 사용
- **순환:** Hold and Wait 관계의 프로세스들이 서로 기다린다.

### 교착 상태 대처 방안

- **예방**: 할당 구조 측면에서, 교착 상태가 발생할 수 있는 요구조건을 만족시키지 않게 한다.
- **회피**: 리소스 할당 측면에서, 교착 상태가 발생할 가능성이 있는 자원 할당을 하지 않는다.
- **탐지 및 회복**: 교착 상태가 발생할 수 있도록 두고 교착 생태가 발생할 경우 찾아내어 고친다.

#### 교착 상태 예방

교착 상태를 방지하기 위해서는 4가지 조건 중에 하나 이상을 불만족시키면 된다.

- **상호 배제 부정:**<br> 여러 개의 프로세스가 동시에 공유 자원을 사용할 수 있다.<br>
  **_문제점:_** 공유 자원에 대한 관리가 이루어질 수 없고 제대로 프로그램이 작동될 수가 없다.

- **점유 및 대기 부정:** <br>
  프로세스가 실행되기 전에 필요한 모든 자원을 다 할당할 때 까지 실행되지 않도록 하거나, 반대로 자원을 요청하기 위해서는 어떠한 자원도 가지지 않았을 때 요청이 가능하도록 한다.<br>
  **_문제점:_** 프로세스가 실행되기 위해서 필요한 자원에 대한 정보를 미리 파악해야 하기 때문에 시간 낭비 발생, 자원의 효율성이 떨어지고 기아상태가 발생할 수 있다.
  <br>

- **비선점 부정:**<br> 다른 프로세스에 할당된 자원을 가져와서 사용 가능하게 한다.<br>
  **_문제점:_** 공유 자원에 대한 동기화에 대한 의미가 깨져버리는 방식으로 실질적으로 불가능

- **순환 대기 부정:** <br>자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.<br>
  **_문제점:_** 그나마 현실적인 방법. 중첩되어 있는 공유자원 사이에 요청 순서를 임의적으로 정해줌으로써 여러 개의 프로세스가 순환형 대기에 머물러 있게 되는 상황을 방지하는 기법이다.

#### 교착 상태 회피

교착 상태 회피는 교착 상태를 피해가는 기법

- **은행원 알고리즘(Banker Algorithm):**<br>

  교착상태에 빠질 가능성이 있는지, 없는지를 판단하기 위해 상태를 ‘안전 상태’와 ‘불안전 상태’로 나눈다. 그리고 운영체제는 안전상태를 유지할 수 있는 요구만 수락해주고, 나머지 요구들은 안전상태를 만족할 때까지 계속 거절한다.

1. 프로세스 시작 시 자신이 필요한 각 자원의 최대 개수를 미리 선언

2. 프로세스에서 자원 요청이 있을 때, 요청을 승인하면 시스템이 안전한 상태로 유지되는 경우에만 할당

3. 불안정 상태가 예상되면 다른 프로세스가 끝날때 까지 대기
   <br>
   <br>

- **자원 할당 그래프 알고리즘(Resource-Allocation Graph Algorithm)**<br>

1. 자원 할당 그래프 예약 간선을 추가한다. (예약 간선): 향후 요청할 수 있는 자원을 가르키는 점선으로 표시된 간선

2. 프로세스 시작 전에 모든 예약 간선들을 자원할당 그래프에 표시<br>

3. 프로세스는 예약 간선으로 설정한 자원에 대해서만 요청할 수 있고, 주기가 형성되지 않을 때에만 자원을 할당

#### 교착 상태 탐지

교착 상태 탐지는 탐지 알고리즘을 사용하여 교착상태가 발생했는지 탐지한다.

- **대기 그래프(wait-for-graph)**<br>
  자원 할당 그래프를 변형한 대기 그래프를 사용하여 탐지한다.<br>
  대기 그래프에 cycle이 있다면 교착 상태를 의미한다.

- **은행원 알고리즘(Banker's Algorithm)**<br>

1. 각 프로세스의 자원 요청 개수를 사용

2. 현재 상태가 안전 상태인지 확인

3. 불안정 상태라면 교착 상태라고 판단

> **탐지 알고리즘 호출 주기**<br>
> 탐지 알고리즘은 오버헤드가 있기 때문에, 얼마나 자주 교착상태가 발생하는지, 얼마나 많은 프로세스가 교착상태에 연루되어 있는지에 따라 호출 빈도를 조절해야 한다.<br>
> Ex)<br>
> 주기적으로 일정 시간마다 호출<br>
> 자원을 요청했는데 즉시 할당되지 못하는 시점에 호출
